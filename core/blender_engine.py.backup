# -*- coding: utf-8 -*-
"""
Blender Render Engine
PyPy最適化対応Blenderレンダリングエンジン
"""

import os
import sys
import subprocess
import threading
import time
import tempfile
import shutil
from pathlib import Path
from typing import Optional, Dict, Any, Callable, List
from glob import glob
import logging
import re # Import re module

# UTF-8エンコーディング設定
if sys.platform.startswith('win'):
    os.environ['PYTHONIOENCODING'] = 'utf-8'

logger = logging.getLogger(__name__)

class BlenderRenderEngine:
    """Blenderレンダリングエンジンクラス"""
    
    def __init__(self, blender_path: Optional[str] = None):
        self.blender_path = blender_path or self._find_blender_path()
        self.process: Optional[subprocess.Popen] = None
        self.is_running = False
        self.progress_callback: Optional[Callable[[float, str], None]] = None
        self.log_callback: Optional[Callable[[str], None]] = None
        self.temp_script_path: Optional[str] = None
        
        # レンダリング統計
        self.stats = {
            'frames_rendered': 0,
            'total_frames': 0,
            'start_time': None,
            'end_time': None,
            'errors': [],
            'warnings': []
        }
        
        self._validate_blender_installation()
    
    def _find_blender_path(self) -> str:
        """Blenderインストールパスを自動検出"""
        possible_paths = [
            r"C:\Program Files\Blender Foundation\Blender 4.5\blender.exe",
            r"C:\Program Files\Blender Foundation\Blender 4.4\blender.exe", 
            r"C:\Program Files\Blender Foundation\Blender 4.3\blender.exe",
            r"C:\Program Files\Blender Foundation\Blender 4.2\blender.exe",
            r"C:\Program Files\Blender Foundation\Blender 4.1\blender.exe",
            r"C:\Program Files\Blender Foundation\Blender 4.0\blender.exe",
            "/usr/bin/blender",
            "/usr/local/bin/blender",
            "/opt/blender/blender",
            "/Applications/Blender.app/Contents/MacOS/Blender"
        ]
        
        for path in possible_paths:
            if os.path.exists(path):
                logger.info(f"Blender検出: {path}")
                return path
        
        # PATHから検索
        try:
            result = subprocess.run(['which', 'blender'], capture_output=True, text=True)
            if result.returncode == 0:
                path = result.stdout.strip()
                logger.info(f"Blender検出(PATH): {path}")
                return path
        except FileNotFoundError:
            pass
        
        # Windowsのwhereコマンド
        try:
            result = subprocess.run(['where', 'blender'], capture_output=True, text=True)
            if result.returncode == 0:
                path = result.stdout.strip().split('\n')[0]
                logger.info(f"Blender検出(WHERE): {path}")
                return path
        except FileNotFoundError:
            pass
        
        raise FileNotFoundError("Blenderが見つかりません。インストールパスを手動で指定してください。")
    
    def _validate_blender_installation(self) -> None:
        """Blenderインストールの検証"""
        if not os.path.exists(self.blender_path):
            raise FileNotFoundError(f"Blender not found at: {self.blender_path}")
        
        try:
            # Blenderバージョン確認
            result = subprocess.run(
                [self.blender_path, '--version'],
                capture_output=True, text=True, timeout=30,
                encoding='utf-8', errors='replace'
            )
            
            if result.returncode == 0:
                version_info = result.stdout.strip()
                logger.info(f"Blender検証成功: {version_info.split(chr(10))[0]}")
            else:
                logger.warning("Blenderバージョン確認に失敗しました")
                
        except subprocess.TimeoutExpired:
            logger.warning("Blenderバージョン確認がタイムアウトしました")
        except Exception as e:
            logger.error(f"Blender検証エラー: {e}")
    
    def set_progress_callback(self, callback: Callable[[float, str], None]) -> None:
        """進捗コールバック設定"""
        self.progress_callback = callback
    
    def set_log_callback(self, callback: Callable[[str], None]) -> None:
        """ログコールバック設定"""
        self.log_callback = callback
    
    def _log(self, message: str) -> None:
        """ログ出力"""
        logger.info(message)
        if self.log_callback:
            self.log_callback(message)
    
    def _update_progress(self, progress: float, message: str) -> None:
        """進捗更新"""
        if self.progress_callback:
            self.progress_callback(progress, message)
    
    def create_render_script(self, settings: Dict[str, Any]) -> str:
        """レンダリング用Pythonスクリプト生成"""
        script_content = f'''
import bpy
import os
import sys

# UTF-8エンコーディング設定
if sys.platform.startswith('win'):
    import locale
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer)
    sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer)

print("Blender Python script started.") # Added for debugging

try:
    # シーン設定
    scene = bpy.context.scene
    
    # 解像度設定
    scene.render.resolution_x = {settings.get('resolution_x', 1920)}
    scene.render.resolution_y = {settings.get('resolution_y', 1080)}
    scene.render.resolution_percentage = {settings.get('resolution_percentage', 100)}
    
    # レンダリングエンジン別設定
    if scene.render.engine == 'CYCLES':
        # Cyclesエンジン設定
        scene.cycles.samples = {settings.get('samples', 128)}
        scene.cycles.use_denoising = {str(settings.get('use_denoising', True)).lower()}
        
        # CUDA/OpenCL設定
        if {str(settings.get('use_gpu', False)).lower()}:
            preferences = bpy.context.preferences
            cycles_preferences = preferences.addons["cycles"].preferences
            
            # GPU デバイス有効化
            cycles_preferences.refresh_devices()
            
            print("Cycles: 利用可能なGPUデバイス:")
            found_gpu = False
            for device in cycles_preferences.devices:
                print(f"  - 名前: {{device.name}}, タイプ: {{device.type}}, 使用中: {{device.use}}")
                if device.type in ['CUDA', 'OPENCL', 'OPTIX']:
                    device.use = True
                    found_gpu = True
                    print(f"  -> GPU デバイス有効化: {{device.name}} ({{device.type}})")
            
            # コンピュートデバイス設定
            if found_gpu and cycles_preferences.has_active_device():
                scene.cycles.device = 'GPU'
                print("Cycles: GPU使用モード (設定済み)")
            else:
                scene.cycles.device = 'CPU'
                print("Cycles: GPU未検出または有効化失敗、CPU使用モード")
        else:
            scene.cycles.device = 'CPU'
            print("Cycles: CPU使用モード (設定済み)")
            
        # タイル設定
        if hasattr(scene.render, 'tile_x'):
            scene.render.tile_x = {settings.get('tile_x', 256)}
            scene.render.tile_y = {settings.get('tile_y', 256)}
    
    elif scene.render.engine == 'BLENDER_EEVEE':
        # Eeveeエンジン設定
        scene.eevee.taa_render_samples = {settings.get('samples', 64)}
        scene.eevee.use_ssr = {str(settings.get('use_ssr', True)).lower()}
        scene.eevee.use_ssr_refraction = {str(settings.get('use_ssr_refraction', False)).lower()}
        scene.eevee.use_bloom = {str(settings.get('use_bloom', False)).lower()}
        scene.eevee.use_volumetric_lights = {str(settings.get('use_volumetric', False)).lower()}
        print("Eevee設定完了")
    
    elif scene.render.engine == 'BLENDER_WORKBENCH':
        # Workbenchエンジン設定
        scene.display.shading.light = '{settings.get('lighting', 'STUDIO')}'
        print("Workbench設定完了")
    
    # 出力設定
    scene.render.image_settings.file_format = '{settings.get('file_format', 'PNG')}'
    
    if scene.render.image_settings.file_format == 'PNG':
        scene.render.image_settings.color_mode = '{settings.get('color_mode', 'RGBA')}'
        scene.render.image_settings.color_depth = '{settings.get('color_depth', '8')}'
        scene.render.image_settings.compression = {settings.get('compression', 15)}
    
    elif scene.render.image_settings.file_format == 'OPEN_EXR':
        scene.render.image_settings.color_depth = '32'
        scene.render.image_settings.exr_codec = 'ZIP'
    
    # 出力パス設定（Windowsパス対応）
    output_path = r"{settings.get('output_path', '').replace(chr(92), chr(92)+chr(92))}"
    scene.render.filepath = output_path
    
    # カメラ設定（存在する場合）
    if '{settings.get('camera_name', '')}' and '{settings.get('camera_name', '')}' in bpy.data.objects:
        scene.camera = bpy.data.objects['{settings.get('camera_name', '')}']
        print(f"カメラ設定: {{scene.camera.name}}")
    
    # ライティング設定
    if {str(settings.get('use_hdri', False)).lower()} and '{settings.get('hdri_path', '')}':
        # HDRI環境設定
        world = scene.world
        if world.use_nodes:
            env_tex_node = world.node_tree.nodes.new('ShaderNodeTexEnvironment')
            env_tex_node.image = bpy.data.images.load(r"{settings.get('hdri_path', '').replace(chr(92), chr(92)+chr(92))}")
            world.node_tree.links.new(env_tex_node.outputs['Color'], 
                                    world.node_tree.nodes['Background'].inputs['Color'])
            print("HDRI環境設定完了")
    
    # レンダリング統計出力
    print(f"=== レンダリング設定完了 ===")
    print(f"エンジン: {{scene.render.engine}}")
    print(f"フレーム範囲: {{scene.frame_start}} - {{scene.frame_end}}")
    print(f"解像度: {{scene.render.resolution_x}} x {{scene.render.resolution_y}}")
    print(f"出力パス: {{scene.render.filepath}}")
    print(f"ファイル形式: {{scene.render.image_settings.file_format}}")
    
    if scene.render.engine == 'CYCLES':
        print(f"サンプル数: {{scene.cycles.samples}}")
        print(f"デバイス: {{scene.cycles.device}}")
    elif scene.render.engine == 'BLENDER_EEVEE':
        print(f"サンプル数: {{scene.eevee.taa_render_samples}}")
    
    print("=== レンダリング開始 ===")
    
    # レンダリング実行
    bpy.ops.render.render(animation=True)
    
    print("=== レンダリング終了 ===")

except Exception as e:
    print(f"ERROR: レンダリング設定エラー: {{e}}")
    import traceback
    traceback.print_exc()
    sys.exit(1)
'''
        
        # 一時スクリプトファイル作成
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False, encoding='utf-8') as f:
            f.write(script_content)
            self.temp_script_path = f.name
        
        return self.temp_script_path
    
    def render(self, blend_file: str, output_dir: str, settings: Dict[str, Any]) -> bool:
        """レンダリング実行"""
        if self.is_running:
            self._log("エラー: 既にレンダリングが実行中です")
            return False
        
        if not os.path.exists(blend_file):
            self._log(f"エラー: Blendファイルが見つかりません: {blend_file}")
            return False
        
        # 出力ディレクトリ作成
        os.makedirs(output_dir, exist_ok=True)
        
        # 設定のデフォルト値設定
        render_settings = {
            'output_path': os.path.join(output_dir, 'render_').replace('\\', '/'),
            **settings
        }
        
        try:
            # レンダリングスクリプト作成
            script_path = self.create_render_script(render_settings)
            
            # 統計初期化
            self.stats = {
                'frames_rendered': 0,
                'total_frames': render_settings.get('frame_end', 250) - render_settings.get('frame_start', 1) + 1,
                'start_time': time.time(),
                'end_time': None,
                'errors': [],
                'warnings': []
            }
            
            # Blenderコマンド構築
            cmd = [
                self.blender_path,
                '-b',  # バックグラウンド
                blend_file,
                '-s', str(render_settings.get('frame_start', 1)),  # 開始フレーム
                '-e', str(render_settings.get('frame_end', 250)),    # 終了フレーム
                '-o', os.path.join(output_dir, 'render_').replace('\\', '/'), # 出力パスとファイル名プレフィックス
                '-P', script_path,  # スクリプト実行
                '-a' # アニメーションレンダリング
            ]
            
            # 追加オプション (Cyclesエンジン強制はスクリプト内で処理)
            # if render_settings.get('use_gpu', False):
            #     cmd.extend(['-E', 'CYCLES']) 
            
            self._log(f"最終レンダリングコマンド: {' '.join(cmd)}") # Changed log message for clarity
            
            # プロセス開始
            self.is_running = True
            self.process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                encoding='utf-8',
                errors='replace',
                cwd=output_dir
            )
            
            # 進捗監視スレッド開始
            monitor_thread = threading.Thread(target=self._monitor_progress, args=(output_dir,))
            monitor_thread.daemon = True
            monitor_thread.start()
            
            # プロセス完了待ち
            return_code = self.process.wait()
            
            # 統計更新
            self.stats['end_time'] = time.time()
            render_time = self.stats['end_time'] - self.stats['start_time']
            
            if return_code == 0:
                self._log(f"レンダリング完了! 時間: {render_time:.2f}秒")
                self._update_progress(100.0, "レンダリング完了")
                return True
            else:
                self._log(f"レンダリング失敗 (終了コード: {return_code})")
                return False
                
        except Exception as e:
            self._log(f"レンダリングエラー: {e}")
            self.stats['errors'].append(str(e))
            return False
        finally:
            self.is_running = False
            self._cleanup_temp_files()
    
    def _monitor_progress(self, output_dir: str) -> None:
        """レンダリング進捗監視"""
        last_reported_frame = 0
        
        while self.is_running and self.process and self.process.poll() is None:
            try:
                if self.process.stdout:
                    line = self.process.stdout.readline()
                    if line:
                        line = line.strip()
                        self._log(f"Blender: {line}") # Log all Blender output for debugging

                        # Parse frame progress
                        # Parse frame progress using regex
                        match = re.search(r"Fra:(\d+)", line)
                        if match:
                            try:
                                current_frame = int(match.group(1))
                                
                                # Ensure total_frames is not zero to avoid division by zero
                                if self.stats['total_frames'] > 0 and current_frame >= self.stats['frames_rendered']:
                                    self.stats['frames_rendered'] = current_frame
                                    progress = (current_frame / self.stats['total_frames']) * 100.0
                                    message = f"フレーム {current_frame}/{self.stats['total_frames']} 完了"
                                    
                                    self._update_progress(progress, message)
                                    last_reported_frame = current_frame
                            except Exception as e:
                                logger.warning(f"Blender進捗解析エラー: {e} (Line: {line})")
                        
                        
                        # Error/Warning logging
                        if 'ERROR' in line:
                            self.stats['errors'].append(line)
                        elif 'WARNING' in line:
                            self.stats['warnings'].append(line)
                
                time.sleep(0.1) # Shorter polling interval for more responsive updates
                
            except Exception as e:
                self._log(f"進捗監視エラー: {e}")
                break
    
    def cancel_render(self) -> bool:
        """レンダリングキャンセル"""
        if not self.is_running or not self.process:
            return False
        
        try:
            self.process.terminate()
            
            # プロセス終了待ち
            try:
                self.process.wait(timeout=10)
            except subprocess.TimeoutExpired:
                self.process.kill()
                self.process.wait()
            
            self.is_running = False
            self._log("レンダリングがキャンセルされました")
            return True
            
        except Exception as e:
            self._log(f"レンダリングキャンセルエラー: {e}")
            return False
        finally:
            self._cleanup_temp_files()
    
    def _cleanup_temp_files(self) -> None:
        """一時ファイルクリーンアップ"""
        if self.temp_script_path and os.path.exists(self.temp_script_path):
            try:
                os.remove(self.temp_script_path)
                self.temp_script_path = None
            except Exception as e:
                logger.warning(f"一時ファイル削除警告: {e}")
    
    def get_render_stats(self) -> Dict[str, Any]:
        """レンダリング統計取得"""
        stats = self.stats.copy()
        
        if stats['start_time'] and stats['end_time']:
            stats['total_time'] = stats['end_time'] - stats['start_time']
            if stats['frames_rendered'] > 0:
                stats['time_per_frame'] = stats['total_time'] / stats['frames_rendered']
            else:
                stats['time_per_frame'] = 0
        else:
            stats['total_time'] = 0
            stats['time_per_frame'] = 0
        
        stats['completion_rate'] = (stats['frames_rendered'] / stats['total_frames']) * 100 if stats['total_frames'] > 0 else 0
        
        return stats
    
    def validate_blend_file(self, blend_file: str) -> Dict[str, Any]:
        """Blendファイルの検証"""
        if not os.path.exists(blend_file):
            return {'valid': False, 'error': 'ファイルが存在しません'}
        
        try:
            # Blenderでファイル情報取得
            info_script = '''
import bpy
import json

info = {
    "scene_name": bpy.context.scene.name,
    "render_engine": bpy.context.scene.render.engine,
    "frame_start": bpy.context.scene.frame_start,
    "frame_end": bpy.context.scene.frame_end,
    "resolution_x": bpy.context.scene.render.resolution_x,
    "resolution_y": bpy.context.scene.render.resolution_y,
    "cameras": [obj.name for obj in bpy.data.objects if obj.type == 'CAMERA'],
    "lights": [obj.name for obj in bpy.data.objects if obj.type == 'LIGHT'],
    "meshes": len([obj for obj in bpy.data.objects if obj.type == 'MESH']),
    "materials": len(bpy.data.materials),
    "has_animation": any(obj.animation_data for obj in bpy.data.objects if obj.animation_data)
}

print("BLEND_INFO:" + json.dumps(info, ensure_ascii=False))
'''
            
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False, encoding='utf-8') as f:
                f.write(info_script)
                info_script_path = f.name
            
            try:
                cmd = [self.blender_path, '-b', blend_file, '-P', info_script_path]
                result = subprocess.run(
                    cmd, capture_output=True, text=True, timeout=60,
                    encoding='utf-8', errors='replace'
                )
                
                # 出力からファイル情報を抽出
                for line in result.stdout.split('\n'):
                    if line.startswith('BLEND_INFO:'):
                        import json
                        info_data = json.loads(line[11:])
                        info_data['valid'] = True
                        return info_data
                
                return {'valid': False, 'error': 'ファイル情報の取得に失敗'}
                
            finally:
                os.remove(info_script_path)
                
        except subprocess.TimeoutExpired:
            return {'valid': False, 'error': 'ファイル検証タイムアウト'}
        except Exception as e:
            return {'valid': False, 'error': f'検証エラー: {e}'}
    
    def estimate_render_time(self, blend_file: str, settings: Dict[str, Any]) -> Dict[str, float]:
        """レンダリング時間推定"""
        try:
            # 単一フレームでテストレンダリング
            test_settings = settings.copy()
            test_settings.update({
                'frame_start': settings.get('frame_start', 1),
                'frame_end': settings.get('frame_start', 1),  # 1フレームのみ
                'samples': min(settings.get('samples', 128), 32)  # サンプル数制限
            })
            
            # テスト用出力ディレクトリ
            with tempfile.TemporaryDirectory() as temp_dir:
                start_time = time.time()
                
                # テストレンダリング実行
                if self.render(blend_file, temp_dir, test_settings):
                    test_time = time.time() - start_time
                    
                    # 実際の設定での推定時間計算
                    sample_ratio = settings.get('samples', 128) / test_settings['samples']
                    frame_count = settings.get('frame_end', 250) - settings.get('frame_start', 1) + 1
                    
                    estimated_time_per_frame = test_time * sample_ratio
                    estimated_total_time = estimated_time_per_frame * frame_count
                    
                    return {
                        'test_time': test_time,
                        'estimated_time_per_frame': estimated_time_per_frame,
                        'estimated_total_time': estimated_total_time,
                        'estimated_hours': estimated_total_time / 3600
                    }
                else:
                    return {'error': 'テストレンダリング失敗'}
                    
        except Exception as e:
            return {'error': f'時間推定エラー: {e}'}
    
    def __del__(self):
        """デストラクタ"""
        if self.is_running:
            self.cancel_render()
        self._cleanup_temp_files()
